import { Scene } from 'phaser';

export interface SpriteConfig {
  key: string;
  path: string;
  frameWidth?: number;
  frameHeight?: number;
}

export interface AtlasConfig {
  key: string;
  imagePath: string;
  dataPath: string;
}

export interface AnimationConfig {
  key: string;
  spriteKey: string;
  frames: number[] | { start: number; end: number } | string[];
  frameRate: number;
  repeat?: number;
}

export interface AssetManifest {
  atlases: AtlasConfig[];
  sprites: SpriteConfig[];
  animations: AnimationConfig[];
}

export class AssetLoader {
  private scene: Scene;

  constructor(scene: Scene) {
    this.scene = scene;
  }

  /**
   * Load texture atlases generated by the art pipeline
   */
  loadAtlases(atlases: AtlasConfig[]) {
    atlases.forEach(atlas => {
      this.scene.load.atlas(atlas.key, atlas.imagePath, atlas.dataPath);
    });
  }

  /**
   * Load individual sprite sheets
   */
  loadSprites(sprites: SpriteConfig[]) {
    sprites.forEach(sprite => {
      if (sprite.frameWidth && sprite.frameHeight) {
        this.scene.load.spritesheet(
          sprite.key,
          sprite.path,
          { frameWidth: sprite.frameWidth, frameHeight: sprite.frameHeight }
        );
      } else {
        this.scene.load.image(sprite.key, sprite.path);
      }
    });
  }

  /**
   * Create animations from sprite sheets or atlases
   */
  createAnimations(animations: AnimationConfig[]) {
    animations.forEach(anim => {
      let frames: Phaser.Types.Animations.AnimationFrame[];
      
      if (Array.isArray(anim.frames)) {
        if (typeof anim.frames[0] === 'string') {
          // Atlas frame names
          frames = (anim.frames as string[]).map(frameName => ({ 
            key: anim.spriteKey, 
            frame: frameName 
          }));
        } else {
          // Frame indices
          frames = (anim.frames as number[]).map(frame => ({ 
            key: anim.spriteKey, 
            frame 
          }));
        }
      } else {
        // Frame range
        frames = this.scene.anims.generateFrameNumbers(anim.spriteKey, anim.frames);
      }

      this.scene.anims.create({
        key: anim.key,
        frames: frames,
        frameRate: anim.frameRate,
        repeat: anim.repeat ?? -1
      });
    });
  }

  /**
   * Load all assets from a manifest
   */
  loadFromManifest(manifest: AssetManifest) {
    this.loadAtlases(manifest.atlases);
    this.loadSprites(manifest.sprites);
  }

  /**
   * Create all animations from a manifest (call after preload)
   */
  createAnimationsFromManifest(manifest: AssetManifest) {
    this.createAnimations(manifest.animations);
  }

  static getCharacterAnimations(spriteKey: string): AnimationConfig[] {
    return [
      {
        key: `${spriteKey}_idle_down`,
        spriteKey,
        frames: [0],
        frameRate: 1,
        repeat: 0
      },
      {
        key: `${spriteKey}_idle_up`,
        spriteKey,
        frames: [12],
        frameRate: 1,
        repeat: 0
      },
      {
        key: `${spriteKey}_idle_left`,
        spriteKey,
        frames: [4],
        frameRate: 1,
        repeat: 0
      },
      {
        key: `${spriteKey}_idle_right`,
        spriteKey,
        frames: [8],
        frameRate: 1,
        repeat: 0
      },
      {
        key: `${spriteKey}_walk_down`,
        spriteKey,
        frames: { start: 0, end: 3 },
        frameRate: 8
      },
      {
        key: `${spriteKey}_walk_left`,
        spriteKey,
        frames: { start: 4, end: 7 },
        frameRate: 8
      },
      {
        key: `${spriteKey}_walk_right`,
        spriteKey,
        frames: { start: 8, end: 11 },
        frameRate: 8
      },
      {
        key: `${spriteKey}_walk_up`,
        spriteKey,
        frames: { start: 12, end: 15 },
        frameRate: 8
      }
    ];
  }
}